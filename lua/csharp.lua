local HEADLINE =
    [[
// This source code was generated by regenerator"
using System;
using System.Runtime.InteropServices;
using HRESULT = System.Int32;
]]

local INT_MAX = 2147483647
local TYPE_MAP = {
    Void = "void",
    Bool = "bool",
    Int8 = "sbyte",
    Int16 = "short",
    Int32 = "int",
    Int64 = "long",
    UInt8 = "byte",
    UInt16 = "ushort",
    UInt32 = "uint",
    UInt64 = "ulong",
    Float = "float",
    Double = "double",
    -- https://docs.microsoft.com/en-us/windows/win32/winprog/windows-data-types
    LPCSTR = "string",
    LPSTR = "string",
    BOOL = "int",
    BYTE = "byte",
    BYTE = "byte",
    INT = "int",
    UINT = "uint",
    FLOAT = "float",
    LPVOID = "IntPtr",
    GUID = "Guid",
    IID = "Guid"
}

local ESCAPE_SYMBOLS = {ref = true, ["in"] = true}

local function CSEscapeName(src)
    if ESCAPE_SYMBOLS[src] then
        return "_" .. src
    end
    return src
end

local function isInterface(decl)
    decl = decl.typedefSource

    if decl.class ~= "Struct" then
        return false
    end

    if decl.definition then
        -- resolve forward decl
        decl = decl.definition
    end

    return decl.isInterface
end

local function CSType(t, isParam)
    local name = TYPE_MAP[t.class]
    if name then
        return name
    end
    if t.class == "Typedef" then
        local name = TYPE_MAP[t.name]
        if name then
            return name
        end
    end

    if t.class == "Pointer" then
        -- return DPointer(t)
        if t.ref.type.name == "ID3DInclude" then
            return "IntPtr"
        elseif t.ref.type.class == "Void" then
            return "IntPtr"
        elseif isInterface(t.ref.type) then
            if t.ref.type.name == "IUnknown" then
                return "IntPtr"
            else
                return string.format("%s", CSType(t.ref.type, isParam))
            end
        else
            local typeName = CSType(t.ref.type, isParam)
            if isParam then
                return string.format("ref %s", typeName)
            else
                return "IntPtr"
            end
        end
    elseif t.class == "Reference" then
        -- return DPointer(t)
        local typeName = CSType(t.ref.type, isParam)
        typeName = string.format("ref %s", typeName)
        return typeName
    elseif t.class == "Array" then
        -- return DArray(t)
        local a = t
        if isParam then
            return string.format("ref %s", CSType(a.ref.type, isParam))
        else
            return string.format("%s[%d]", CSType(a.ref.type, isParam), a.size)
        end
    else
        if #t.name == 0 then
            return nil
        end
        return t.name
    end
end

local function CSTypedefDecl(f, t)
    -- print(t, t.ref)
    local dst = CSType(t.ref.type)
    if not dst then
        -- nameless
        writeln(f, "// typedef target nameless")
        return
    end

    if t.name == dst then
        -- f.writefln("// samename: %s", t.m_name);
        return
    end

    if string.sub(dst, 1, 4) == "ref " then
        writefln(f, "    public struct %s { public IntPtr Value; }", t.name)
    else
        writefln(f, "    public struct %s { public %s Value; }", t.name, dst)
    end
end

local function CSEnumDecl(f, decl, omitEnumPrefix, indent)
    if not decl.name then
        writefln(f, "// enum nameless", indent)
        return
    end

    if omitEnumPrefix then
        decl.omit()
    end

    writefln(f, "%spublic enum %s", indent, decl.name)
    writefln(f, "%s{", indent)
    for i, value in ipairs(decl.values) do
        if value.value > INT_MAX then
            writefln(f, "%s    %s = unchecked((int)0x%x),", indent, value.name, value.value)
        else
            writefln(f, "%s    %s = 0x%x,", indent, value.name, value.value)
        end
    end
    writefln(f, "%s}", indent)
end

local function CSFunctionDecl(f, decl, indent, isMethod, option)
    indent = indent or ""

    if not isMethod then
        if decl.isExternC then
            writefln(f, '%s[DllImport("some.dll")]', indent)
        else
            writefln(f, '%s[DllImport("some.dll", EntryPoint="mangle")]', indent)
        end
        writef(f, "%spublic static extern %s %s(", indent, CSType(decl.ret), decl.name)
    else
        -- interface
        writef(f, "%s%s %s(", indent, CSType(decl.ret), decl.name)
    end

    local isFirst = true
    for i, param in ipairs(decl.params) do
        if isFirst then
            isFirst = false
        else
            f:write(", ")
        end

        local dst = CSType(param.ref.type, true)
        -- if param.ref.isConst then
        --     dst = string.format("const(%s)", dst)
        -- end
        writef(f, "%s %s", dst, CSEscapeName(param.name))
        -- TODO: dfault value = getValue(param, option.param_map)
    end
    writeln(f, ");")
end

local SKIP_METHODS = {QueryInterface = true, AddRef = true, Release = true}

local function CSStructDecl(f, decl, option)
    -- assert(!decl.m_forwardDecl);
    local name = decl.name
    if not name or #name == 0 then
        writeln(f, "    // struct nameless")
        return
    end

    if decl.isInterface then
        -- com interface
        if decl.isForwardDecl then
            return
        end

        -- interface
        if decl.iid then
            writefln(f, '    [Guid("%s")]', decl.iid)
        end
        writef(f, "    public interface %s", name)
        if decl.base then
            if decl.base.name == "IUnknown" then
            else
                writef(f, ": %s", decl.base.name)
            end
        end

        writeln(f)
        writeln(f, "    {")

        -- methods
        for i, method in ipairs(decl.methods) do
            if SKIP_METHODS[method.name] then
                -- writefln(f, "        // skip %s", method.name)
            else
                CSFunctionDecl(f, method, "        ", true, option)
            end
        end
        writeln(f, "    }")
    else
        if decl.isForwardDecl then
            -- forward decl
            if #decl.fields > 0 then
                error("forward decl has fields")
            end
            writefln(f, "    public struct %s;", name)
        else
            writeln(f, "    [StructLayout(LayoutKind.Sequential)]")
            writefln(f, "    public struct %s", name)
            writeln(f, "    {")
            for i, field in ipairs(decl.fields) do
                local typeName = CSType(field.ref.type)
                if not typeName then
                    local fieldType = field.ref.type
                    if fieldType.class == "Struct" then
                        if fieldType.isUnion then
                            -- for i, unionField in ipairs(fieldType.fields) do
                            --     local unionFieldTypeName = CSType(unionField.ref.type)
                            --     writefln(f, "        %s %s;", unionFieldTypeName, CSEscapeName(unionField.name))
                            -- end
                            -- writefln(f, "    }")
                            writefln(f, "        // anonymous union")
                        else
                            writefln(f, "       // anonymous struct %s;", CSEscapeName(field.name))
                        end
                    else
                        error("unknown")
                    end
                else
                    if field.ref.type.class == 'Array' then
                        local a = field.ref.type
                        local arraySize = a.size
                        if a.ref.type.class == 'Array' then
                            -- 多次元
                            a = a.ref.type
                            arraySize = arraySize * a.size
                        end
                        writefln(f, "        [MarshalAs(UnmanagedType.ByValArray, SizeConst=%d)]public %s[] %s;", arraySize, CSType(a.ref.type), CSEscapeName(field.name))
                    else
                        writefln(f, "        public %s %s;", typeName, CSEscapeName(field.name))
                    end
                end
            end

            writeln(f, "    }")
        end
    end
end

local function CSDecl(f, decl, option)
    if decl.class == "Typedef" then
        CSTypedefDecl(f, decl)
    elseif decl.class == "Enum" then
        CSEnumDecl(f, decl, option.omitEnumPrefix, "    ")
    elseif decl.class == "Function" then
        CSFunctionDecl(f, decl, "        ", false, option)
    elseif decl.class == "Struct" then
        CSStructDecl(f, decl, option)
    else
        error("unknown", decl)
    end
end

local function CSConstant(f, macroDefinition, macro_map)
    if not isFirstAlpha(macroDefinition.tokens[1]) then
        local text = macro_map[macroDefinition.name]
        if text then
            writefln(f, "        %s", text)
        else
            local value = table.concat(macroDefinition.tokens, " ")
            local valueType = "int"
            if string.find(value, '%"') then
                valueType = "string"
            elseif string.find(value, "f") then
                valueType = "float"
            elseif string.find(value, "%.") then
                valueType = "double"
            elseif string.find(value, "UL") then
                valueType = "ulong"
            end
            if valueType == "int" then
                local num = tonumber(value)
                if num then
                    if num > INT_MAX then
                        valueType = "uint"
                    end
                else
                    -- fail tonumber
                    -- ex. "( 1 << 0 )"
                end
            end
            writefln(f, "        public const %s %s = %s;", valueType, macroDefinition.name, value)
        end
    end
end

local function CSSource(f, packageName, source, option)
    macro_map = option["macro_map"] or {}
    declFilter = option["filter"]
    omitEnumPrefix = option["omitEnumPrefix"]

    writeln(f, HEADLINE)
    writefln(f, "namespace %s {", packageName)

    if option.injection then
        local inejection = option.injection[source.name]
        if inejection then
            writefln(f, inejection)
        end
    end

    -- const
    writeln(f, "    public static partial class Constants {")
    for j, macroDefinition in ipairs(source.macros) do
        CSConstant(f, macroDefinition, macro_map)
    end
    writeln(f, "    }")

    -- types
    local funcs = {}
    for j, decl in ipairs(source.types) do
        if not declFilter or declFilter(decl) then
            if decl.class == "Function" then
                table.insert(funcs, decl)
            else
                CSDecl(f, decl, option)
            end
        end
    end

    -- funcs
    writefln(f, "    public static class %s {", source.name)
    for i, decl in ipairs(funcs) do
        CSDecl(f, decl, option)
    end
    writeln(f, "    }")

    writeln(f, "}")

    return hasComInterface
end

local function ComUtil(packageName)
end

local function CSProj(f)
    f:write(
        [[
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFramework>netstandard2.0</TargetFramework>
  </PropertyGroup>

</Project>
    ]]
    )
end

local function CSGenerate(sourceMap, dir, option)
    -- clear dir
    if file.exists(dir) then
        printf("rmdir %s", dir)
        file.rmdirRecurse(dir)
    end

    local packageName = basename(dir)
    local hasComInterface = false
    for k, source in pairs(sourceMap) do
        -- write each source
        if not source.empty then
            local path = string.format("%s/%s.cs", dir, source.name)
            printf("writeTo: %s", path)
            file.mkdirRecurse(dir)

            do
                -- open
                local f = io.open(path, "w")
                if CSSource(f, packageName, source, option) then
                    hasComInterface = true
                end
                io.close(f)
            end
        end
    end

    if hasComInterface then
        -- write utility
        local path = string.format("%s/ComUtil.cs", dir)
        local f = io.open(path, "w")
        ComUtil(f, packageName)
        io.close(f)
    end

    do
        -- csproj
        local path = string.format("%s/ShrimpDX.csproj", dir)
        local f = io.open(path, "w")
        CSProj(f)
        io.close(f)
    end
end

return {
    Generate = CSGenerate
}
