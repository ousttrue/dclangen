function printf(fmt, ...)
    print(string.format(fmt, ...))
end

--
-- -X => opt[X] = true
-- -X 1 => opt[X] = 1
-- -XY => error. use --XY
-- --YY => opt[YY] = true
-- --YY "hello" => opt[YY] = "hello"
--
function getopt(arg)
    local opt = {}
    function push_value(key, value)
        local lastvalue = opt[key]
        if lastvalue then
            if type(lastvalue) == "table" then
                if lastvalue[#lastvalue] == true then
                    -- replace
                    lastvalue[#lastvalue] = value
                else
                    -- push
                    table.insert(lastvalue, value)
                end
            else
                if lastvalue == true then
                    -- replace
                    opt[key] = value
                else
                    -- push
                    opt[key] = {lastvalue, value}
                end
            end
        else
            opt[key] = value
        end
    end

    local lastkey = nil
    for k, v in ipairs(arg) do
        if string.sub(v, 1, 2) == "--" then
            lastkey = string.sub(v, 3)
            push_value(lastkey, true)
        elseif string.sub(v, 1, 1) == "-" then
            key = string.sub(v, 2)
            if string.len(key) > 1 then
                error(string.format('"%s" option name must 1 length. use "-%s"', v, v))
            end
            lastkey = key
            push_value(lastkey, true)
        else
            if lastkey then
                push_value(lastkey, v)
            end
            lastkey = nil
        end
    end
    return opt
end

function print_table(t, indent)
    indent = indent or ""
    for k, v in pairs(t) do
        printf("%s%s => %s", indent, k, v)
        if type(v) == "table" then
            print_table(v, indent .. "  ")
        end
    end
end

function writeln(f, text)
    f:write(text)
    f:write("\n")
end

function writefln(f, fmt, ...)
    f:write(string.format(fmt, ...))
    f:write("\n")
end

function rfind(src, pred)
    local i = nil
    -- print(src)
    for i = #src, 1, -1 do
        local c = string.sub(src, i, i)
        -- printf("%d %s", i, c)
        if pred(c) then
            -- printf("found: %s %d", src, i)
            return i
        end
    end
end

function basename(src)
    local function pred(c)
        if c == "/" or c == "\\" then
            return true
        end
    end
    local i = rfind(src, pred)
    if i then
        return string.sub(src, i + 1)
    end
    return src
end

function isFirstAlpha(src)
    return string.match(src, "^%a")
end

HEADLINE = "// This source code was generated by regenerator"

local DESCAPE_SYMBOLS = {module = true, ref = true, ["in"] = true}

function DEscapeName(src)
    if DESCAPE_SYMBOLS[src] then
        return "_" .. src
    end
    return src
end

-- avoid c style cast
DMACRO_MAP = {
    D3D_COMPILE_STANDARD_FILE_INCLUDE = "enum D3D_COMPILE_STANDARD_FILE_INCLUDE = cast(void*)1;",
    ImDrawCallback_ResetRenderState = "enum ImDrawCallback_ResetRenderState = cast( ImDrawCallback ) ( - 1 );",
    LUA_VERSION = 'enum LUA_VERSION = "Lua " ~ LUA_VERSION_MAJOR ~ "." ~ LUA_VERSION_MINOR;',
    LUA_REGISTRYINDEX = "enum LUA_REGISTRYINDEX = ( - 1000000 - 1000 );",
    LUAL_NUMSIZES = "enum LUAL_NUMSIZES = ( ( lua_Integer ).sizeof  * 16 + ( lua_Number ).sizeof  );",
    LUA_VERSUFFIX = 'enum LUA_VERSUFFIX = "_" ~ LUA_VERSION_MAJOR ~ "_" ~ LUA_VERSION_MINOR;'
}

DTYPE_MAP = {
    Void = "void",
    Bool = "bool",
    Int8 = "char",
    Int16 = "short",
    Int32 = "int",
    Int64 = "long",
    UInt8 = "ubyte",
    UInt16 = "ushort",
    UInt32 = "uint",
    UInt64 = "ulong",
    Float = "float",
    Double = "double"
}

function isInterface(decl)
    decl = decl.typedefSource

    if decl.class ~= "Struct" then
        return false
    end

    if decl.definition then
        -- resolve forward decl
        decl = decl.definition
    end

    return decl.isInterface
end

function DPointer(p)
    if p.ref.type.name == "ID3DInclude" then
        return "void*   "
    elseif isInterface(p.ref.type) then
        return string.format("%s", DType(p.ref.type))
    else
        return string.format("%s*", DType(p.ref.type))
    end
end

function DArray(a)
    return string.format("%s[%d]", DType(a.ref.type), a.size)
end

function DType(t)
    local name = DTYPE_MAP[t.class]
    if name then
        return name
    end
    if t.class == "Pointer" then
        return DPointer(t)
    elseif t.class == "Array" then
        return DArray(t)
    else
        return t.name
    end
end

function DTypedefDecl(f, t)
    -- print(t, t.ref)
    local dst = DType(t.ref.type)
    if dst then
        if t.name == dst then
            -- f.writefln("// samename: %s", t.m_name);
            return
        end

        writefln(f, "alias %s = %s;", t.name, dst)
        return
    end

    -- nameless
    writeln(f, "// typedef target nameless")
end

function DEnumDecl(f, decl, omitEnumPrefix)
    if not decl.name then
        writeln(f, "// enum nameless")
        return
    end

    writef(f, "enum %s", decl.name)
    f.writeln()

    if omitEnumPrefix then
        omit(decl)
    end

    writeln(f, "{")
    for i, value in ipairs(decl.values) do
        writefln(f, "    %s = 0x%x,", value.name, value.value)
    end
    writeln(f, "}")
end

SKIP_METHODS = {QueryInterface = true, AddRef = true, Release = true}

function DStructDecl(f, decl, typedefName)
    -- assert(!decl.m_forwardDecl);
    local name = typedefName or decl.name
    if not name then
        writeln(f, "// struct nameless")
        return
    end

    if decl.isInterface then
        -- com interface
        if decl.isForwardDecl then
            return
        end

        -- interface
        writef(f, "interface %s", name)
        if decl.base then
            writef(f, ": %s", decl.base.name)
        end

        writeln(f)
        writeln(f, "{")
        if not decl.iid.empty then
            writefln(f, '    static const iidof = parseGUID("%s");', decl.iid.toString())
        end

        -- methods
        for i, method in ipairs(decl.methods) do
            if SKIP_METHODS[method.name] then
                writefln(f, "    // skip %s", method.name)
            else
                DFunctionDecl(f, method, "    ", true)
            end
        end
        writeln(f, "}")
    else
        if decl.isForwardDecl then
            -- forward decl
            if #decl.fields > 0 then
                error("forward decl has fields")
            end
            writefln(f, "struct %s;", name)
        else
            writefln(f, "struct %s", name)
            writeln(f, "{")
            for i, field in ipairs(decl.fields) do
                local typeName = DType(field.type)
                if not typeName then
                    local fieldType = field.type
                    if fieldType.class == "Struct" then
                        if fieldType.isUnion then
                            writefln(f, "    union {")
                            for i, unionField in ipairs(structDecl.fields) do
                                local unionFieldTypeName = DType(unionField.type)
                                writefln(f, "        %s %s;", unionFieldTypeName, DEscapeName(unionField.name))
                            end
                            writefln(f, "    }")
                        else
                            writefln(f, "   // anonymous struct %s;", DEscapeName(field.name))
                        end
                    else
                        error("unknown")
                    end
                else
                    writefln(f, "    %s %s;", typeName, DEscapeName(field.name))
                end
            end

            writeln(f, "}")
        end
    end
end

function DFunctionDecl(f, decl, indent, isMethod)
    indent = indent or ""
    if (not isMethod) and (not decl.dllExport) then
        -- filtering functions
        -- target library(d3d11.h, libclang.h, lua.h) specific...

        -- for D3D11CreateDevice ... etc
        local retType = decl.ret
        -- if (!retType)
        -- {
        --     return;
        -- }
        if retType.name ~= "HRESULT" then
            return
        end
    -- debug auto isCom = true;
    end

    f:write(indent)
    if decl.isExternC then
        f:write("extern(C) ")
    end

    f:write(DType(decl.ret))
    f:write(" ")
    f:write(decl.name)
    f:write("(")

    local isFirst = true
    for i, param in ipairs(decl.params) do
        if isFirst then
            isFirst = false
        else
            f:write(", ")
        end

        if param.ref.hasConstRecursive then
            f:write("const ")
        end

        f:write(string.format("%s %s", DType(param.ref.type), DEscapeName(param.name)))
    end
    writeln(f, ");")
end

function DDecl(f, decl, omitEnumPrefix)
    if decl.class == "Typedef" then
        DTypedefDecl(f, decl)
    elseif decl.class == "Enum" then
        DEnumDecl(f, decl)
    elseif decl.class == "Struct" then
        DStructDecl(f, decl)
    elseif decl.class == "Function" then
        DFunctionDecl(f, decl)
    else
        error("unknown", decl)
    end
end

return _G