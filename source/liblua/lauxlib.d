// This source code was generated by regenerator
module liblua.lauxlib;
import liblua.lua;
import liblua.corecrt_wstdio;
enum LUA_ERRFILE = ( LUA_ERRERR + 1 );
enum LUA_LOADED_TABLE = "_LOADED";
enum LUA_PRELOAD_TABLE = "_PRELOAD";
enum LUAL_NUMSIZES = ( ( lua_Integer ).sizeof  * 16 + ( lua_Number ).sizeof  );
// macro function: luaL_checkversion ( L ) luaL_checkversion_ ( L , LUA_VERSION_NUM , LUAL_NUMSIZES );
enum LUA_NOREF = ( - 2 );
enum LUA_REFNIL = ( - 1 );
// macro function: luaL_loadfile ( L , f ) luaL_loadfilex ( L , f , NULL );
// macro function: luaL_newlibtable ( L , l ) lua_createtable ( L , 0 , sizeof ( l ) / sizeof ( ( l ) [ 0 ] ) - 1 );
// macro function: luaL_newlib ( L , l ) ( luaL_checkversion ( L ) , luaL_newlibtable ( L , l ) , luaL_setfuncs ( L , l , 0 ) );
// macro function: luaL_argcheck ( L , cond , arg , extramsg ) ( ( void ) ( ( cond ) || luaL_argerror ( L , ( arg ) , ( extramsg ) ) ) );
// macro function: luaL_checkstring ( L , n ) ( luaL_checklstring ( L , ( n ) , NULL ) );
// macro function: luaL_optstring ( L , n , d ) ( luaL_optlstring ( L , ( n ) , ( d ) , NULL ) );
// macro function: luaL_typename ( L , i ) lua_typename ( L , lua_type ( L , ( i ) ) );
// macro function: luaL_dofile ( L , fn ) ( luaL_loadfile ( L , fn ) || lua_pcall ( L , 0 , LUA_MULTRET , 0 ) );
// macro function: luaL_dostring ( L , s ) ( luaL_loadstring ( L , s ) || lua_pcall ( L , 0 , LUA_MULTRET , 0 ) );
// macro function: luaL_getmetatable ( L , n ) ( lua_getfield ( L , LUA_REGISTRYINDEX , ( n ) ) );
// macro function: luaL_opt ( L , f , n , d ) ( lua_isnoneornil ( L , ( n ) ) ? ( d ) : f ( L , ( n ) ) );
// macro function: luaL_loadbuffer ( L , s , sz , n ) luaL_loadbufferx ( L , s , sz , n , NULL );
// macro function: luaL_addchar ( B , c ) ( ( void ) ( ( B ) -> n < ( B ) -> size || luaL_prepbuffsize ( ( B ) , 1 ) ) , ( ( B ) -> b [ ( B ) -> n ++ ] = ( c ) ) );
// macro function: luaL_addsize ( B , s ) ( ( B ) -> n += ( s ) );
// macro function: luaL_prepbuffer ( B ) luaL_prepbuffsize ( B , LUAL_BUFFERSIZE );
enum LUA_FILEHANDLE = "FILE*";
// macro function: lua_writestring ( s , l ) fwrite ( ( s ) , sizeof ( char ) , ( l ) , stdout );
// macro function: lua_writeline ( ) ( lua_writestring ( "\n" , 1 ) , fflush ( stdout ) );
// macro function: lua_writestringerror ( s , p ) ( fprintf ( stderr , ( s ) , ( p ) ) , fflush ( stderr ) );
struct luaL_Reg
{
    const(char)* name;
    lua_CFunction func;
}
struct luaL_Buffer
{
    char* b;
    ulong size;
    ulong n;
    lua_State* L;
    char[8192] initb;
}
struct luaL_Stream
{
    FILE* f;
    lua_CFunction closef;
}
extern(C) void luaL_checkversion_(lua_State* L, double ver, ulong sz);
extern(C) int luaL_loadstring(lua_State* L, const(char)* s);
extern(C) lua_State* luaL_newstate();
extern(C) long luaL_len(lua_State* L, int idx);
extern(C) const(char)* luaL_gsub(lua_State* L, const(char)* s, const(char)* p, const(char)* r);
extern(C) int luaL_loadbufferx(lua_State* L, const(char)* buff, ulong sz, const(char)* name, const(char)* mode);
extern(C) void luaL_unref(lua_State* L, int t, int _ref);
extern(C) int luaL_loadfilex(lua_State* L, const(char)* filename, const(char)* mode);
extern(C) int luaL_ref(lua_State* L, int t);
extern(C) int luaL_execresult(lua_State* L, int stat);
extern(C) void luaL_setfuncs(lua_State* L, const(luaL_Reg)* l, int nup);
extern(C) void luaL_traceback(lua_State* L, lua_State* L1, const(char)* msg, int level);
extern(C) void luaL_addstring(luaL_Buffer* B, const(char)* s);
extern(C) void luaL_addvalue(luaL_Buffer* B);
extern(C) void luaL_pushresult(luaL_Buffer* B);
extern(C) int luaL_getsubtable(lua_State* L, int idx, const(char)* fname);
extern(C) void luaL_addlstring(luaL_Buffer* B, const(char)* s, ulong l);
extern(C) void luaL_buffinit(lua_State* L, luaL_Buffer* B);
extern(C) char* luaL_prepbuffsize(luaL_Buffer* B, ulong sz);
extern(C) void luaL_requiref(lua_State* L, const(char)* modname, lua_CFunction openf, int glb);
extern(C) void luaL_pushresultsize(luaL_Buffer* B, ulong sz);
extern(C) int luaL_fileresult(lua_State* L, int stat, const(char)* fname);
extern(C) int luaL_error(lua_State* L, const(char)* fmt);
extern(C) const(char)* luaL_checklstring(lua_State* L, int arg, ulong* l);
extern(C) const(char)* luaL_optlstring(lua_State* L, int arg, const(char)* def, ulong* l);
extern(C) double luaL_checknumber(lua_State* L, int arg);
extern(C) double luaL_optnumber(lua_State* L, int arg, double def);
extern(C) int luaL_argerror(lua_State* L, int arg, const(char)* extramsg);
extern(C) int luaL_callmeta(lua_State* L, int obj, const(char)* e);
extern(C) const(char)* luaL_tolstring(lua_State* L, int idx, ulong* len);
extern(C) int luaL_getmetafield(lua_State* L, int obj, const(char)* e);
extern(C) int luaL_checkoption(lua_State* L, int arg, const(char)* def, const(char)** lst);
extern(C) long luaL_checkinteger(lua_State* L, int arg);
extern(C) void luaL_checkstack(lua_State* L, int sz, const(char)* msg);
extern(C) void* luaL_testudata(lua_State* L, int ud, const(char)* tname);
extern(C) void* luaL_checkudata(lua_State* L, int ud, const(char)* tname);
extern(C) void luaL_where(lua_State* L, int lvl);
extern(C) long luaL_optinteger(lua_State* L, int arg, long def);
extern(C) void luaL_setmetatable(lua_State* L, const(char)* tname);
extern(C) void luaL_checkany(lua_State* L, int arg);
extern(C) int luaL_newmetatable(lua_State* L, const(char)* tname);
extern(C) void luaL_checktype(lua_State* L, int arg, int t);
extern(C) char* luaL_buffinitsize(lua_State* L, luaL_Buffer* B, ulong sz);
