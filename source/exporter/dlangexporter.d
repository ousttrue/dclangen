module exporter.dlangexporter;
import exporter.source;
import clangdecl;
import std.ascii;
import std.stdio;
import std.string;
import std.path;
import std.traits;
import std.file;
import std.experimental.logger;
import std.algorithm;
import sliceview;

///
/// D言語向けに出力する
///

immutable HEADLINE = "// This source code was generated by dclangen";

string DEscapeName(string src)
{
    switch (src)
    {
    case "module":
        return "_module";

    default:
        return src;
    }
}

Decl GetTypedefSource(Decl decl)
{
    while (true)
    {
        Typedef typedefDecl = cast(Typedef) decl;
        if (!typedefDecl)
        {
            break;
        }
        decl = typedefDecl.m_typeref.type;
    }
    return decl;
}

static bool isInterface(Decl decl)
{
    debug
    {
        auto userDecl = cast(UserDecl) decl;
        if (userDecl)
        {
            if (userDecl.m_name == "ID3DBlob")
            {
                auto a = 0;
            }
        }
    }

    decl = decl.GetTypedefSource();

    Struct structDecl = cast(Struct) decl;
    if (!structDecl)
    {
        return false;
    }

    if (structDecl.m_definition)
    {
        // resolve forward decl
        structDecl = structDecl.m_definition;
    }

    return structDecl.isInterface;
}

string GetName(Decl decl)
{
    auto userDecl = cast(UserDecl) decl;
    if (!userDecl)
    {
        return "";
    }
    return userDecl.m_name;
}

string DPointer(Pointer t)
{
    if (t.m_typeref.type.GetName() == "ID3DInclude")
    {
        return "void*";
    }
    else if (isInterface(t.m_typeref.type))
    {
        return format("%s", DType(t.m_typeref.type));
    }
    else
    {
        return format("%s*", DType(t.m_typeref.type));
    }
}

string DArray(Array t)
{
    return format("%s[%d]", DType(t.m_typeref.type), t.m_size);
}

string DType(Decl t)
{
    return castSwitch!((Pointer decl) => DPointer(decl),
            (Array decl) => DArray(decl), (UserDecl decl) => decl.m_name, //
            (Void _) => "void", (Bool _) => "bool", (Int8 _) => "byte",
            (Int16 _) => "short", (Int32 _) => "int", (Int64 _) => "long",
            (UInt8 _) => "ubyte", (UInt16 _) => "ushort", (UInt32 _) => "uint",
            (UInt64 _) => "ulong", (Float _) => "float", (Double _) => "double", //
            () => format("unknown(%s)", t))(t);
}

void DTypedefDecl(File* f, Typedef t)
{
    auto dst = DType(t.m_typeref.type);
    if (dst)
    {
        if (t.m_name == dst)
        {
            // f.writefln("// samename: %s", t.m_name);
            return;
        }

        f.writefln("alias %s = %s;", t.m_name, dst);
        return;
    }

    // nameless
    f.writeln("// typedef target nameless");
}

void DStructDecl(File* f, Struct decl, string typedefName = null)
{
    debug if (decl.m_name.endsWith("Impl"))
    {
        auto a = 0;
    }
    // assert(!decl.m_forwardDecl);
    auto name = typedefName ? typedefName : decl.m_name;
    if (!name)
    {
        f.writeln("// struct nameless");
        return;
    }

    if (decl.isInterface)
    {
        // com interface
        if (decl.m_forwardDecl)
        {
            return;
        }

        // interface
        f.writef("interface %s", name);
        if (decl.m_base)
        {
            f.writef(": %s", decl.m_base.m_name);
        }
        f.writeln();
        f.writeln("{");
        if (!decl.m_iid.empty)
        {
            f.writefln("    static const iidof = parseGUID(\"%s\");", decl.m_iid.toString());
        }
        // methods
        foreach (method; decl.m_methods)
        {
            DFucntionDecl(f, method, "    ", true);
        }
        f.writeln("}");
    }
    else
    {
        if (decl.m_forwardDecl)
        {
            // forward decl
            assert(decl.m_fields.empty);
            f.writefln("struct %s;", name);
        }
        else
        {

            f.writefln("struct %s", name);
            f.writeln("{");
            foreach (field; decl.m_fields)
            {
                auto typeName = DType(field.type);
                if (!typeName)
                {
                    auto structDecl = cast(Struct) field.type;
                    if (structDecl)
                    {
                        if (structDecl.m_isUnion)
                        {
                            // typedef struct D3D11_VIDEO_COLOR
                            // {
                            // union 
                            //     {
                            //     int YCbCr;
                            //     float RGBA;
                            //     } 	;
                            // }                        
                            f.writefln("    union {");
                            foreach (unionField; structDecl.m_fields)
                            {
                                auto unionFieldTypeName = DType(unionField.type);
                                f.writefln("        %s %s;", unionFieldTypeName,
                                        DEscapeName(unionField.name));
                            }
                            f.writefln("    }");
                        }
                        else
                        {
                            f.writefln("   // anonymous struct %s;", DEscapeName(field.name));
                        }
                    }
                    else
                    {
                        throw new Exception("unknown");
                    }
                }
                else
                {
                    f.writefln("    %s %s;", typeName, DEscapeName(field.name));
                }
            }
            f.writeln("}");
        }
    }
}

immutable string[string] replace_map;

shared static this()
{
    replace_map = [
        "_D3D_PARAMETER_FLAGS": "D3D_PF_", //
        "_D3D_SHADER_VARIABLE_TYPE": "D3D_SVT_", //
        "_D3D_SHADER_VARIABLE_CLASS": "D3D_SVC_", ///
        "_D3D_RESOURCE_RETURN_TYPE": "D3D_RETURN_TYPE_", //
        "_D3D_CBUFFER_TYPE": "D3D_CT_", //
        "_D3D_SHADER_INPUT_TYPE": "D3D_SIT_", //
        "_D3D_SHADER_VARIABLE_FLAGS": "D3D_SVF_", //
        "_D3D_SHADER_INPUT_FLAGS": "D3D_SIF_", //
        "_D3D_SHADER_CBUFFER_FLAGS": "D3D_CBF_", //
        "D3D_REGISTER_COMPONENT_TYPE": "D3D_REGISTER_COMPONENT_", //
    ];
}

immutable string[] suffixes = [
    "_PRIMITIVE", "_FLAGS", "_FLAG", "_MODE", "_CLASSIFICATION", // d3d
];

string getOmitEnumNameForWindows(string name)
{
    if (name in replace_map)
    {
        name = replace_map[name];
    }

    foreach (suffix; suffixes)
    {
        if (name.endsWith(suffix))
        {
            name = name[0 .. $ - (suffix.length - 1)];
            break;
        }
    }

    if (name[$ - 1] != '_')
    {
        name ~= '_';
    }

    return name;
}

immutable clangEnumSuffix = ["Kind", "Flags", "Severity"];

string getOmitEnumName(string name)
{
    if (name.indexOf('_') != -1)
    {
        return getOmitEnumNameForWindows(name);
    }
    else
    {
        // for clang
        foreach (suffix; clangEnumSuffix)
        {
            if (name.endsWith(suffix))
            {
                return name[0 .. $ - suffix.length] ~ "_";
            }
        }

        return name;
    }
}

void DEnumDecl(File* f, Enum decl, bool omitEnumPrefix)
{
    if (!decl.m_name)
    {
        f.writeln("// enum nameless");
        return;
    }

    f.writef("enum %s", decl.m_name);
    auto maxValue = decl.maxValue;
    if (maxValue > uint.max)
    {
        f.write(": ulong");
    }
    f.writeln();

    auto omitName = getOmitEnumName(decl.m_name);
    f.writeln("{");
    foreach (value; decl.m_values)
    {
        auto name = value.name;
        if (omitEnumPrefix && name.startsWith(omitName))
        {
            // "D3D_SRV_DIMENSION_UNKNOWN" => "_UNKNOWN"
            name = name[omitName.length - 1 .. $];
        }
        f.writefln("    %s = 0x%x,", name, value.value);
    }
    f.writeln("}");
}

void DFucntionDecl(File* f, Function decl, string indent, bool isMethod)
{
    if (!isMethod && !decl.m_dllExport)
    {
        auto retType = cast(UserDecl) decl.m_ret;
        if (!retType)
        {
            return;
        }
        if (retType.m_name != "HRESULT")
        {
            return;
        }
        debug auto isCom = true; // D3D11CreateDevice ... etc
    }
    f.write(indent);
    if (decl.m_externC)
    {
        f.write("extern(C) ");
    }
    f.write(DType(decl.m_ret));
    f.write(" ");
    f.write(decl.m_name);
    f.write("(");

    auto isFirst = true;
    foreach (param; decl.m_params)
    {
        if (isFirst)
        {
            isFirst = false;
        }
        else
        {
            f.write(", ");
        }
        if (param.typeRef.isConst)
        {
            f.write("const ");
        }
        f.write(format("%s %s", DType(param.typeRef.type), DEscapeName(param.name)));
    }
    f.writeln(");");
}

void DDecl(File* f, Decl decl, bool omitEnumPrefix)
{
    castSwitch!( //
            (Typedef decl) => DTypedefDecl(f, decl), //
            (Enum decl) => DEnumDecl(f,
                decl, omitEnumPrefix), //
            (Struct decl) => DStructDecl(f, decl), //
            (Function decl) => DFucntionDecl(f, decl, "", false) //
            )(decl);
}

void dlangExport(Source[string] sourceMap, string dir, bool omitEnumPrefix)
{
    // clear dir
    if (exists(dir))
    {
        logf("rmdir %s", dir);
        rmdirRecurse(dir);
    }

    // write each source
    // auto sourcemap = makeView(m_sourceMap);
    auto useGuid = false;
    foreach (k, source; sourceMap)
    {
        // source.writeTo(dir);
        if (source.empty)
        {
            continue;
        }

        auto packageName = dir.baseName.stripExtension;

        // open
        auto path = format("%s/%s.d", dir, source.getName());
        // writeln(stem);
        logf("writeTo: %s(%d)", path, source.m_types.length);
        mkdirRecurse(dir);

        {
            auto f = File(path, "w");
            f.writeln(HEADLINE);
            f.writefln("module %s.%s;", packageName, source.getName());

            // imports
            string[] modules;
            foreach (src; source.m_imports)
            {
                if (!src.empty)
                {
                    f.writefln("import %s.%s;", packageName, src.getName());
                }

                foreach (m; src.m_modules)
                {
                    if (modules.find(m).empty)
                    {
                        f.writefln("import %s;", m);
                        modules ~= m;

                        if (m == moduleName!(core.sys.windows.unknwn))
                        {
                            f.writefln("import %s.guidutil;", packageName);
                            useGuid = true;
                        }
                    }
                }
            }

            // const
            foreach (macroDefinition; source.m_macros)
            {
                if (macroDefinition.tokens[0][0].isAlpha)
                {
                    // typedef ?
                    // IID_ID3DBlob = IID_ID3D10Blob;
                    // INTERFACE = ID3DInclude;
                    continue;
                }
                if (macroDefinition.name == "D3D_COMPILE_STANDARD_FILE_INCLUDE")
                {
                    f.writeln("enum D3D_COMPILE_STANDARD_FILE_INCLUDE = cast(void*)1;");
                }
                else
                {
                    f.writefln("enum %s = %s;", macroDefinition.name,
                            macroDefinition.tokens.join(" "));
                }
            }

            // types
            foreach (decl; source.m_types)
            {
                DDecl(&f, decl, omitEnumPrefix);
            }
        }
    }

    if (useGuid)
    {
        // write utility
        auto packageName = dir.baseName.stripExtension;
        auto path = format("%s/guidutil.d", dir);
        auto f = File(path, "w");
        f.writefln("module %s.guidutil;", packageName);
        f.writeln("
import std.uuid;
import core.sys.windows.basetyps;

GUID parseGUID(string guid)
{
    return toGUID(parseUUID(guid));
}
GUID toGUID(immutable std.uuid.UUID uuid)
{
    ubyte[8] data=uuid.data[8..$];
    return GUID(
                uuid.data[0] << 24
                |uuid.data[1] << 16
                |uuid.data[2] << 8
                |uuid.data[3],

                uuid.data[4] << 8
                |uuid.data[5],

                uuid.data[6] << 8
                |uuid.data[7],

                data
                );
}
");
    }

    // write package.d
    {
        auto packageName = dir.baseName.stripExtension;
        auto path = format("%s/package.d", dir);
        auto f = File(path, "w");
        f.writefln("module %s;", packageName);
        foreach (k, source; sourceMap)
        {
            if (source.empty())
            {
                continue;
            }
            f.writefln("public import %s.%s;", packageName, source.getName());
        }
    }
}
